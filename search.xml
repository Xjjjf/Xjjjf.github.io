<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>力扣每日一题 2020/12/13</title>
    <url>/2020/12/13/217.%20%E5%AD%98%E5%9C%A8%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0/</url>
    <content><![CDATA[<h2 id="题目：217-存在重复元素"><a href="#题目：217-存在重复元素" class="headerlink" title="题目：217. 存在重复元素"></a>题目：217. 存在重复元素</h2><p>难度：简单</p>
<p>给定一个整数数组，判断是否存在重复元素。</p>
<p>如果任意一值在数组中出现至少两次，函数返回 true 。如果数组中每个元素都不相同，则返回 false 。</p>
<p>示例 1:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">输入: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>]</span><br><span class="line">输出: <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>复制</p>
<p>示例 2:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">输入: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">输出: <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<p>复制</p>
<p>示例 3:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">输入: [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">2</span>]</span><br><span class="line">输出: <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>复制</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/contains-duplicate">https://leetcode-cn.com/problems/contains-duplicate</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><blockquote>
<p>运用algorithm中的库函数sort，默认排序从小到大，只需要遍历一次，相邻元素相同返回真，否则返回假</p>
<p>注：一开始用了二重遍历直接超时</p>
</blockquote>
<h2 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">containsDuplicate</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        sort(nums.begin(), nums.end());  <span class="comment">//从小到大排序</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n<span class="number">-1</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == nums[i+<span class="number">1</span>])</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数据结构和算法</category>
      </categories>
      <tags>
        <tag>力扣</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣每日一题 2020/12/12</title>
    <url>/2020/12/12/376.%20%E6%91%86%E5%8A%A8%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<h2 id="题目：376-摆动序列"><a href="#题目：376-摆动序列" class="headerlink" title="题目：376. 摆动序列"></a>题目：376. 摆动序列</h2><p>难度：中等</p>
<p>如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为摆动序列。第一个差（如果存在的话）可能是正数或负数。少于两个元素的序列也是摆动序列。</p>
<p>例如， [1,7,4,9,2,5] 是一个摆动序列，因为差值 (6,-3,5,-7,3) 是正负交替出现的。相反, [1,4,7,2,5] 和 [1,7,4,5,5] 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。</p>
<p>给定一个整数序列，返回作为摆动序列的最长子序列的长度。 通过从原始序列中删除一些（也可以不删除）元素来获得子序列，剩下的元素保持其原始顺序。</p>
<p>示例 1:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">输入: [<span class="number">1</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">2</span>,<span class="number">5</span>]</span><br><span class="line">输出: <span class="number">6</span> </span><br><span class="line">解释: 整个序列均为摆动序列。</span><br></pre></td></tr></table></figure>

<p>复制</p>
<p>示例 2:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">输入: [<span class="number">1</span>,<span class="number">17</span>,<span class="number">5</span>,<span class="number">10</span>,<span class="number">13</span>,<span class="number">15</span>,<span class="number">10</span>,<span class="number">5</span>,<span class="number">16</span>,<span class="number">8</span>]</span><br><span class="line">输出: <span class="number">7</span></span><br><span class="line">解释: 这个序列包含几个长度为 <span class="number">7</span> 摆动序列，其中一个可为[<span class="number">1</span>,<span class="number">17</span>,<span class="number">10</span>,<span class="number">13</span>,<span class="number">10</span>,<span class="number">16</span>,<span class="number">8</span>]。</span><br></pre></td></tr></table></figure>

<p>复制</p>
<p>示例 3:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">输入: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]</span><br><span class="line">输出: <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>复制</p>
<p>进阶:<br>你能否用 O(n) 时间复杂度完成此题?</p>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/wiggle-subsequence">https://leetcode-cn.com/problems/wiggle-subsequence</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><blockquote>
<p>动态规划求解</p>
<p>1.某个序列被称为「上升摆动序列」，当且仅当该序列是摆动序列，且最后一个元素呈上升趋势。如序列 [1,3,2,4][1,3,2,4] 即为「上升摆动序列」</p>
<p>2.某个序列被称为「下降摆动序列」，当且仅当该序列是摆动序列，且最后一个元素呈下降趋势。如序列 [4,2,3,1][4,2,3,1] 即为「下降摆动序列」</p>
<p>3.特别地，对于长度为 1 的序列，它既是「上升摆动序列」，也是「下降摆动序列」</p>
<p>4.序列中的某个元素被称为「峰」，当且仅当该元素两侧的相邻元素均小于它。如序列 [1,3,2,4][1,3,2,4] 中，3就是一个「峰」</p>
<p>5.序列中的某个元素被称为「谷」，当且仅当该元素两侧的相邻元素均大于它。如序列 [1,3,2,4][1,3,2,4] 中，2就是一个「谷」</p>
<p>6.特别地，对于位于序列两端的元素，只有一侧的相邻元素小于或大于它，我们也称其为「峰」或「谷」。如序列 [1,3,2,4][1,3,2,4] 中，1 也是一个「谷」，4 也是一个「峰」</p>
<p>7.因为一段相邻的相同元素中我们最多只能选择其中的一个，所以我们可以忽略相邻的相同元素。现在我们假定序列中任意两个相邻元素都不相同，即要么左侧大于右侧，要么右侧大于左侧。对于序列中既非「峰」也非「谷」的元素，我们称其为「过渡元素」。如序列 [1,2,3,4][1,2,3,4] 中，2 和 3 都是「过渡元素」</p>
</blockquote>
<h2 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">wiggleMaxLength</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();  <span class="comment">//得到容器的元素个数</span></span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">2</span>)  <span class="comment">//如果容器元素个数小于2，一定为摆动序列</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;int&gt; up(n), down(n);  //生成vector&lt;int&gt;的容器，默认是0</span><br><span class="line">        up[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        down[<span class="number">0</span>] = <span class="number">1</span>; <span class="comment">//注意初始元素只有1个，必定是一个摆动序列，一开始没考虑到，答案一直少1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &lt; nums[i<span class="number">-1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                up[i] = up[i - <span class="number">1</span>];</span><br><span class="line">                down[i] = max(up[i - <span class="number">1</span>] + <span class="number">1</span>, down[i - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] &gt; nums[i - <span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                up[i] = max(up[i - <span class="number">1</span>],down[i - <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">                down[i] = down[i - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                up[i] = up[i - <span class="number">1</span>];</span><br><span class="line">                down[i] = down[i - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max(up[n - <span class="number">1</span>], down[n - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数据结构和算法</category>
      </categories>
      <tags>
        <tag>力扣</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣每日一题 2020/12/08</title>
    <url>/2020/12/08/842.%20%E5%B0%86%E6%95%B0%E7%BB%84%E6%8B%86%E5%88%86%E6%88%90%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<h2 id="题目：842-将数组拆分成斐波那契序列"><a href="#题目：842-将数组拆分成斐波那契序列" class="headerlink" title="题目：842. 将数组拆分成斐波那契序列"></a>题目：842. 将数组拆分成斐波那契序列</h2><p>难度：中等</p>
<p>给定一个数字字符串 S，比如 S = “123456579”，我们可以将它分成斐波那契式的序列 [123, 456, 579]。</p>
<p>形式上，斐波那契式序列是一个非负整数列表 F，且满足：</p>
<p>0 &lt;= F[i] &lt;= 2^31 - 1，（也就是说，每个整数都符合 32 位有符号整数类型）；<br>F.length &gt;= 3；<br>对于所有的0 &lt;= i &lt; F.length - 2，都有 F[i] + F[i+1] = F[i+2] 成立。<br>另外，请注意，将字符串拆分成小块时，每个块的数字一定不要以零开头，除非这个块是数字 0 本身。</p>
<p>返回从 S 拆分出来的任意一组斐波那契式的序列块，如果不能拆分则返回 []。</p>
<p>示例 1：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">输入：<span class="string">&quot;123456579&quot;</span></span><br><span class="line">输出：[<span class="number">123</span>,<span class="number">456</span>,<span class="number">579</span>]</span><br></pre></td></tr></table></figure>

<p>复制</p>
<p>示例 2：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">输入: <span class="string">&quot;11235813&quot;</span></span><br><span class="line">输出: [<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">13</span>]</span><br></pre></td></tr></table></figure>

<p>复制</p>
<p>示例 3：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">输入: <span class="string">&quot;112358130&quot;</span></span><br><span class="line">输出: []</span><br><span class="line">解释: 这项任务无法完成。</span><br></pre></td></tr></table></figure>

<p>复制</p>
<p>示例 4：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">输入：<span class="string">&quot;0123&quot;</span></span><br><span class="line">输出：[]</span><br><span class="line">解释：每个块的数字不能以零开头，因此 <span class="string">&quot;01&quot;</span>，<span class="string">&quot;2&quot;</span>，<span class="string">&quot;3&quot;</span> 不是有效答案。</span><br></pre></td></tr></table></figure>

<p>复制</p>
<p>示例 5：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">输入: <span class="string">&quot;1101111&quot;</span></span><br><span class="line">输出: [<span class="number">110</span>, <span class="number">1</span>, <span class="number">111</span>]</span><br><span class="line">解释: 输出 [<span class="number">11</span>,<span class="number">0</span>,<span class="number">11</span>,<span class="number">11</span>] 也同样被接受。</span><br></pre></td></tr></table></figure>

<p>复制</p>
<p>提示：</p>
<ol>
<li>1 &lt;= S.length &lt;= 200</li>
<li>字符串 S 中只含有数字。</li>
</ol>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/split-array-into-fibonacci-sequence">https://leetcode-cn.com/problems/split-array-into-fibonacci-sequence</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><blockquote>
<p>通过DFS暴力枚举找到满足斐波那契式的数据</p>
</blockquote>
<h2 id="解题心得"><a href="#解题心得" class="headerlink" title="解题心得"></a>解题心得</h2><blockquote>
<p>由于初识回溯法算法，因此在编写本次程序十分痛苦，中间也走了不少坑。</p>
<p>算法过程</p>
<p>1.从根节点开始</p>
<p>2.放入一个节点（起始时放入的为根节点）</p>
<p>3.如果这个节点是第一次出现，则放入堆栈中</p>
<p>4.判断该节点的子节点是否搜索完成，</p>
<p>​    a.如果是则将该节点出栈,判断该栈是否为空</p>
<p>​       a.1 若为空则结束</p>
<p>​      a.2 若不为空则取栈顶元素，并回到第2步</p>
<p>​    b.如果没有完成搜索，取未被搜索的根节点，并回到第2步</p>
<p>注：需要注意0是单独元素，开始没有考虑进去，后续在数据迭代移位的过程会把0抹去，影响结果。</p>
</blockquote>
<h2 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">splitIntoFibonacci</span><span class="params">(<span class="built_in">string</span> S)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        dfs(<span class="number">0</span>, S);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> pos, <span class="built_in">string</span> S)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = S.size();</span><br><span class="line">        <span class="keyword">if</span> (pos == n)</span><br><span class="line">            <span class="keyword">return</span> ans.size() &gt; <span class="number">2</span>;           <span class="comment">//如果vector容器小于等于2代表只有前两个数，没有第三个数，失败（Fibonacci数组元素至少是3个）</span></span><br><span class="line">        <span class="keyword">long</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> max_len = S[pos] == <span class="string">&#x27;0&#x27;</span> ? <span class="number">1</span> : <span class="number">10</span>; <span class="comment">//不能有前导0，每个0应该单独出来，解决方法就是把数据循环到0后一位</span></span><br><span class="line">        <span class="keyword">int</span> end = min(max_len + pos, n);  <span class="comment">// 根据元素是否为0，选择迭代次数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = pos; i &lt; end; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it_end = ans.end();  <span class="comment">//得到容器的迭代器，注意指针指向的位置为元素末尾下一位</span></span><br><span class="line">            sum = <span class="number">10</span> * sum + S[i] - <span class="string">&#x27;0&#x27;</span>;  <span class="comment">//根据迭代次数来计算分离的数据，由于是字符形式，转换成数字可以通过减0得到</span></span><br><span class="line">            <span class="keyword">if</span> (sum &gt; INT_MAX)   <span class="comment">//为了满足数组元素都符合 32 位有符号整数类型</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> (ans.size() &gt; <span class="number">1</span>)  <span class="comment">//当容器的大小大于1时，再去判断斐波那契式</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">long</span> num = (*(it_end - <span class="number">1</span>));</span><br><span class="line">                num += (*(it_end - <span class="number">2</span>));</span><br><span class="line">                <span class="keyword">if</span> (sum &gt; num) <span class="keyword">break</span>;  <span class="comment">//如果前两个元素小于现在的元素，直接跳出循环，此次搜索结果为假</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (sum &lt; num) <span class="keyword">continue</span>;  <span class="comment">//如果前两个元素大于现在的元素，则不进行下面赋值的操作，</span></span><br><span class="line">                                               <span class="comment">//仅仅再次进入循环，把字符串下一位数据拿出来</span></span><br><span class="line">            &#125;</span><br><span class="line">            ans.push_back(sum);   <span class="comment">//数据填充，1.初始数据填充 2.满足斐波那契式的式子填充</span></span><br><span class="line">            <span class="keyword">if</span> (dfs(i + <span class="number">1</span>, S))   <span class="comment">//进行下一步DFS搜索，如果运行到这一步，说明这次DFS搜索结果正确(初始数据填充也会进行到这一步)</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;   </span><br><span class="line">            <span class="keyword">else</span>              <span class="comment">//如果下一步DFS搜索结果为假，则进行回溯，把填充的数据回收</span></span><br><span class="line">                ans.pop_back();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据结构和算法</category>
      </categories>
      <tags>
        <tag>力扣</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣每日一题 2020/12/07</title>
    <url>/2020/12/07/861.%20%E7%BF%BB%E8%BD%AC%E7%9F%A9%E9%98%B5%E5%90%8E%E7%9A%84%E5%BE%97%E5%88%86/</url>
    <content><![CDATA[<h2 id="题目：861-翻转矩阵后的得分"><a href="#题目：861-翻转矩阵后的得分" class="headerlink" title="题目：861. 翻转矩阵后的得分"></a>题目：861. 翻转矩阵后的得分</h2><p>难度：中等</p>
<p>有一个二维矩阵 A 其中每个元素的值为 0 或 1 。</p>
<p>移动是指选择任一行或列，并转换该行或列中的每一个值：将所有 0 都更改为 1，将所有 1 都更改为 0。</p>
<p>在做出任意次数的移动后，将该矩阵的每一行都按照二进制数来解释，矩阵的得分就是这些数字的总和。</p>
<p>返回尽可能高的分数。</p>
<p>示例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">输入：[[<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>],[<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>]]</span><br><span class="line">输出：<span class="number">39</span></span><br><span class="line">解释：</span><br><span class="line">转换为 [[<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>],[<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>]]</span><br><span class="line"><span class="number">0b1111</span> + <span class="number">0b1001</span> + <span class="number">0b1111</span> = <span class="number">15</span> + <span class="number">9</span> + <span class="number">15</span> = <span class="number">39</span></span><br></pre></td></tr></table></figure>

<p>复制</p>
<p>提示：</p>
<ol>
<li>1 &lt;= A.length &lt;= 20</li>
<li>1 &lt;= A[0].length &lt;= 20</li>
<li>A[i][j] 是 0 或 1</li>
</ol>
<p>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/score-after-flipping-matrix/">https://leetcode-cn.com/problems/score-after-flipping-matrix/</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。  </p>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><blockquote>
<p>每一行必须是1开头，也就是说，第一列的值都是1。<br>这样也是有依据的，这样转换后就增大了每行二进制数。不管后面怎么变，都不能动摇这个基本<br>第一点就可以说整体提升，那么下面就再小刀一下，尽可能的让每一行的1的个数多点，但是不能用行转换来得到更多的1，而是通过列转换来得到更多的1，那么怎么列转换呢？转换时的依据是什么呢？<br>依据是：每一列的0个数多于1的个数时，那么这一列就转换，否则不转换。    </p>
</blockquote>
<h2 id="解题代码"><a href="#解题代码" class="headerlink" title="解题代码"></a>解题代码</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">matrixScore</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; A)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//保证第一列都是1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (A[i][<span class="number">0</span>] == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; A[<span class="number">0</span>].size(); j++)</span><br><span class="line">                &#123;</span><br><span class="line">                    A[i][j] ^= <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//保证后面每一列的1个数大于0</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;  A[<span class="number">0</span>].size(); j++)</span><br><span class="line">        &#123;   </span><br><span class="line">            <span class="keyword">int</span> zeronum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.size(); i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (A[i][j] == <span class="number">0</span>)</span><br><span class="line">                    zeronum++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">2</span> * zeronum &gt; A.size())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.size(); i++)</span><br><span class="line">                &#123;</span><br><span class="line">                    A[i][j] ^= <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//求和</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it = A[i].begin();</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = A[<span class="number">0</span>].size()<span class="number">-1</span>; j&gt;=<span class="number">0</span>; j--)</span><br><span class="line">                &#123;   </span><br><span class="line">                    sum = sum + (*it)*<span class="built_in">pow</span>(<span class="number">2</span>, j);</span><br><span class="line">                    it++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构和算法</category>
      </categories>
      <tags>
        <tag>力扣</tag>
      </tags>
  </entry>
</search>
